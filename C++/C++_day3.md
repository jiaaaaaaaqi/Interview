### 虚函数表
在有虚函数的类中，存在一个虚函数指针，该指针指向一张虚函数表，当子类继承基类的时候，也会继承其虚函数表。当子类重写基类中的虚函数时，会将虚函数表中的地址替换成重写的函数地址。
![](虚函数表.png)   
(图片来自 https://www.cnblogs.com/bewolf/p/9352116.html)

### char* 和 char[] 的区别
```cpp
char *s1 = "abc";
char s2[] = "abc"
```
以上两种定义方式直接输出结果，则都能正常输出。但修改 $s1$ 的内容会引起程序崩溃，而修改 $s2$ 的内容不会。

因为 $abc$ 是保存在常量区内，而第一种方式是利用指针直接指向常量区，第二种方式是通过数组将 $abc$ 复制出来，存储在栈区内，所以修改 $s2$ 的值不会崩溃而修改 $s1$ 的值会。

### $C$++ 程序内存结构
$C$++ 程序的内存分区自低地址至高地址分别分为 **代码区、常量区、静态(全局)存储区、自由存储区、堆区、栈区**。
1. 代码区存放用户代码。
2. 常量区存放常量，这里的量不可被改变。
3. 静态变量和全局变量存放在静态存储区内，一直到程序全部结束后才会释放内存。
4. 自由存储区内存由 $new、delete$ 分配和回收。
5. 堆区内存由 $malloc、free$ 分配和回收，若申请了空间但忘记释放，容易造成内存泄漏。
6. 栈区存放函数内的局部变量，函数参数。当数据过了作用范围后，系统就会回收内存。

### $C$++ 中常量
定义常量有两种方法，第一种是使用 $define$ 定义，另一种是通过 $const$ 修饰，常量不可被修改。全局对象存放在静态区内，局部对象存放在栈区内。

### $const$ 关键字作用
1. 通过 $const$ 修饰的变量，成为常变量，不可被修改。
2. 通过 $const$ 修饰的类成员函数，成为常函数，该函数不可修改类内的成员变量。
3. 两个类成员同名函数，一个带有 $const$，一个不带 $const$，相当于重载，会根据类对象是否是 $const$ 修饰的决定调用哪个函数。
4. 通过 $const$ 修饰指针
```cpp
    int x = 10;
    const int *a = &x;
    int* const b = &x;
```
其中 $const$ 修饰的分别是 $*a$ 和 $b$，那么对于 $a$ 而言，可以修改 $a$ 的指向，而不能修改 $*a$ 所指向的值，对于 $b$ 而言，可以修改 $*b$ 所指的值，而不能修改 $b$ 的指向。

### 为什么函数参数入栈顺序从右到左
为了支持 **不定长参数函数**
```cpp
int add(int num, ...) {
	va_list valist;
	int sum = 0;
    int i;
    va_start(valist, num);
    for (i = 0; i < num; i++) {
        sum += va_arg(valist, int);
    }
    va_end(valist);
    return sum;
}
```
如果是从左到右入栈，$num$ 变量将在栈底，而不定长参数需要这个 $num$ 来确定元素的个数，在栈底自然是取不出来的。所以通过从右向左入栈，可以获得不定长参数的长度。

### $C98$ 和 $C11$ 中的枚举
$C98$ 中的枚举是不限定作用域的
```cpp
enum color{red, green, blue, yellow};
enum color2{red, green};    // ERROR，因为 red 和 green 已经在 color 中定义过了
auto x = red;   //OK，因为 red 没有限定作用域
auto y = color::red;   //OK
```
$C11$ 中引入了强类型枚举，是限定作用域的
```cpp
enum struct color{red, green, blue, yellow};
enum struct color2{red, green}; // OK，red 和 green 在不同作用域内
auto x = red;   // ERROR，red 没有指定作用域
auto y = color::red;
```
强类型转换的优点在于
- 限定作用域的枚举类型将名字空间污染降低
- 限定作用域的枚举类型是强类型的，无法通过隐式转换到其他类型，而不限定的枚举类型可以自动转换为整形

### 宏定义和枚举的区别
1. 枚举是一种实体，占内存。宏定义是一种表达式，不占内存。
2. 枚举在编译阶段进行处理，宏定义在与编译阶段就完成了文本替换。

### 空类
如果一个空类不被使用，则在编译器什么也不做。

但空类还是带着一些默认的函数，这些函数只有被使用的时候才会产生，主要是六个函数
- 默认构造函数
- 默认析构函数
- 拷贝构造函数
- 赋值运算符 (operator=)
- 取址运算符 (operator&)(一对，一个非 $const$ 的，一个 $const$ 的)