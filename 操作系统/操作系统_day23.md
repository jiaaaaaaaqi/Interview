### 僵尸进程
1. 正常进程
   - 正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。但子进程的结束和父进程的运行是一个异步过程，也就是说父进程无法预知子进程什么时候结束。一个进程完成他的工作后，它的父进程要调用 $wait/waitpid$ 函数来收集子进程的终止状态，并把他彻底销毁后返回，如果没有等到这样的一个子进程，就会阻塞在这里等待。
2. 孤儿进程
   - 如果一个父进程推出，而他的子进程还在运行，那么这些子进程就变成了孤儿进程。孤儿进程会由 $init$ 进程收养。
3. 僵尸进程
   - 如果子进程退出，而父进程没有使用 $wait/waitpid$ 函数，那么这些进程的进程描述符仍然保存在系统中，这些进程被称为僵尸进程。
   - 僵尸进程是一个必经的阶段，如果子进程退出，父进程还没有使用 $wait/waitpid$ 函数，此时就是僵尸进程，等到父进程处理以后才消失。如果父进程在子进程结束之前退出，子进程就会由 $init$ 进程接管，$init$ 进程会以父进程的身份处理僵尸进程。

僵尸进程的危害：
- 僵尸进程如果不被释放，就会一直占用系统的进程号。而系统的进程号是有限的，如果有大量的僵尸进程，可用的进程就会减少。

如何避免僵尸进程
- 外部解决
  - 通过 $kill$ 消灭产生僵尸进程的进程，那么僵尸进程就变成了孤儿进程，由 $init$ 进程处理。
- 内部解决
  - 子进程退出时向父进程发送信号，父进程接收到信号时，在信号处理中调用 $wait$ 处理僵尸进程
  - 两次 $fork$：父进程 $fork$ 后马上 $wait/waitpid$，子进程在 $fork$ 一次后马上 $exit$，孙进程完成父进程中本来要完成的事情，由于是孙进程的父进程已经退出了，它变成了孤儿进程，由 $init$ 进程处理。

### 线程池
线程池就是首先创建一些线程，它们的集合称为线程池。线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。线程池可以很好的提高性能。

### 如何实现线程池
1. 创建一个队列，用来维护要处理的任务，给队列加上互斥锁。
2. 创建 $n$ 个线程，通过条件锁来维护正在运行的线程数目。
3. 初始时，信号量为空，每个线程都在等待信号量。
4. 生产者向获得互斥锁后向队列中加入任务，并让信号量增加一。

### 大端小端以及如何判断大端小端
- 大端：指低字节存储在高地址
- 小端：指低字节存储在低地址

可用通过 $union$ 来判断系统是大端还是小端，因为 $union$ 总是从低地址开始存放
```cpp
int main() {
	// freopen("in", "r", stdin);
	union T {
		int x;
		char y;
	} t;
	t.x = 0x1234;
	if(t.y == 0x12)	printf("da duan\n");
	else	printf("xiao duan\n");
	return 0;
}
```
